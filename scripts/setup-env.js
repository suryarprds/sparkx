#!/usr/bin/env node
/**
 * Database Configuration Loader
 * Loads YAML configuration based on is_local flag and sets up environment variables
 * Usage: node scripts/setup-env.js
 * Control: Edit config.yaml -> is_local: true (SQLite) or false (PostgreSQL)
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

// Load YAML config
const configPath = path.join(rootDir, 'config.yaml');
let config;

try {
  const fileContents = fs.readFileSync(configPath, 'utf8');
  config = yaml.load(fileContents);
} catch (error) {
  console.error('‚ùå Error loading config.yaml:', error.message);
  process.exit(1);
}

// Single control: is_local determines everything
const isLocal = config.is_local;
const activeEnv = isLocal ? 'local' : 'remote';
const provider = isLocal ? 'sqlite' : 'postgresql';

if (!config.environments[activeEnv]) {
  console.error(`‚ùå Environment "${activeEnv}" not found in config.yaml`);
  console.error(`Available environments: ${Object.keys(config.environments).join(', ')}`);
  process.exit(1);
}

const envConfig = config.environments[activeEnv];

// Generate Prisma schema based on is_local flag
const schemaPath = path.join(rootDir, 'prisma', 'schema.prisma');
try {
  const existingSchema = fs.readFileSync(schemaPath, 'utf8');
  
  // Extract only the models (everything after datasource block)
  const datasourceMatch = existingSchema.match(/datasource\s+db\s*\{[^}]*\}\n*/);
  let modelsContent = '';
  if (datasourceMatch) {
    const endIndex = existingSchema.indexOf(datasourceMatch[0]) + datasourceMatch[0].length;
    modelsContent = existingSchema.substring(endIndex);
  }
  
  // Regenerate schema with correct provider
  const newSchema = `// Prisma Schema for SparkX Robot Fleet Management
// Supports both SQLite (local dev) and PostgreSQL (Azure production)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "${provider}"
  url      = env("DATABASE_URL")
}

${modelsContent}`;

  fs.writeFileSync(schemaPath, newSchema.trim() + '\n');
  console.log(`‚úÖ Updated Prisma provider to: ${provider}`);
} catch (error) {
  console.error('‚ö†Ô∏è  Warning: Could not update Prisma schema:', error.message);
}

// Generate .env content
const envContent = `
# Auto-generated by scripts/setup-env.js
# Generated from: config.yaml
# Active Environment: ${activeEnv}
# Last Updated: ${new Date().toISOString()}

# Database Configuration
DATABASE_URL="${envConfig.database_url}"
DB_PROVIDER="${envConfig.provider}"
DB_ENV="${activeEnv}"

# Server Configuration
PORT=${config.server.port}
NODE_ENV=${config.server.node_env}
CORS_ORIGIN="${config.server.cors.origin}"
API_BASE_URL="${config.server.api.base_url}"

# Prisma Configuration
PRISMA_LOG_LEVEL="${config.prisma.log_level}"
PRISMA_LOG_QUERIES=${config.prisma.log_queries}
`.trim();

// Write .env file
const envPath = path.join(rootDir, '.env');
try {
  fs.writeFileSync(envPath, envContent);
  console.log(`‚úÖ Environment switched to: ${envConfig.name}`);
  console.log(`üìù Updated: .env`);
  console.log(`üìç Provider: ${envConfig.provider}`);
  console.log(`üìå Database: ${envConfig.description}`);
  console.log('');
  console.log('üí° Next steps:');
  console.log('   npm run db:push');
  if (activeEnv === 'local') {
    console.log('   npm run db:seed');
  }
  console.log('   npm run dev:all');
} catch (error) {
  console.error('‚ùå Error writing .env file:', error.message);
  process.exit(1);
}
